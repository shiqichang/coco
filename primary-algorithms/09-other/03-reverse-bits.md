# 03 颠倒二进制位

> 🌈 **初级算法系列之其它**
>
> 你的无畏源于无知。

## 题目描述

颠倒给定的 32 位无符号整数的二进制位。

### 示例1

> 输入: 00000010100101000001111010011100
> 输出: 00111001011110000010100101000000
> 解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
> 因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。

### 示例2

> 输入：11111111111111111111111111111101
> 输出：10111111111111111111111111111111
> 解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
> 因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。

### 提示

- 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响

  您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。

- 在 Java 中，编译器使用[二进制补码](https://baike.baidu.com/item/二进制补码/5295284)记法来表示有符号整数。因此，在上面的 **示例 2** 中，输入表示有符号整数 `-3`，输出表示有符号

  整数 `-1073741825`。

### 进阶

如果多次调用这个函数，你将如何优化你的算法？

## 题解

```python
def reverse_bits(n):
    """ 逐位颠倒 """
    ret, power = 0, 31
    while n:
        ret += (n & 1) << power
        n >>= 1
        power -= 1
    return ret
```

```python
# 带记忆化的按字节颠倒
import functools

class Solution:
    # @param n, an integer
    # @return an integer
    def reverseBits(self, n):
        ret, power = 0, 24
        while n:
            ret += self.reverseByte(n & 0xff) << power
            n = n >> 8
            power -= 8
        return ret

    # memoization with decorator
    @functools.lru_cache(maxsize=256)
    def reverseByte(self, byte):
        return (byte * 0x0202020202 & 0x010884422010) % 1023
```

```python
class Solution:
    # @param n, an integer
    # @return an integer
    def reverseBits(self, n):
        n = (n >> 16) | (n << 16)
        n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8)
        n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4)
        n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2)
        n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1)
        return n
```

🍥 **考察要点**：位移、分治

🍬 **解题思路**：逐位颠倒，时间复杂度为 O(logn)；带记忆化的按字节颠倒；位操作➕分治。

🍉 **时间复杂度**：O(1)

🍭 **空间复杂度**：O(1)
